{"ast":null,"code":"/* eslint-disable no-restricted-syntax */\nexport const defaultPrecisionMap = {\n  bytes: 0,\n  KB: 0,\n  MB: 1,\n  GB: 1,\n  TB: 2,\n  PB: 2\n};\nexport const getFormattedSize = (bytes = 0, precision = defaultPrecisionMap) => {\n  const units = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n\n  if (Number.isNaN(parseFloat(String(bytes))) || !Number.isFinite(bytes)) {\n    return '?';\n  }\n\n  let unitIndex = 0;\n\n  while (bytes >= 1024) {\n    bytes /= 1024;\n    unitIndex += 1;\n  }\n\n  const unit = units[unitIndex];\n\n  if (typeof precision === 'number') {\n    return `${bytes.toFixed(+precision)} ${unit}`;\n  }\n\n  return `${bytes.toFixed(precision[unit])} ${unit}`;\n};\n/**\n * Validate if the size of a file is bigger than the expected size\n *\n * @param bytes Size in bytes\n * @param maximumSize Maximum size in MB\n * @returns `true` is the file size is under or equals to the expected size. IF not, returns `false`\n */\n\nexport const checkFileSize = (bytes, maximumSize) => {\n  const currentSizeInMB = bytes / 1024 / 1024;\n\n  if (currentSizeInMB >= maximumSize) {\n    return false;\n  }\n\n  return true;\n};\nexport const checkFileMIMEType = (fileType, allowedMimeTypes) => {\n  const mimeTypes = allowedMimeTypes.split(', ');\n\n  for (const mimeType of mimeTypes) {\n    let typeCriteria = '';\n\n    if (mimeType.includes('*')) {\n      typeCriteria = mimeType.substring(0, mimeType.indexOf('/'));\n    } else if (mimeType.includes('.') && !mimeTypes.includes('/')) {\n      typeCriteria = mimeType.substring(mimeType.indexOf('.') + 1);\n    } else {\n      typeCriteria = mimeType;\n    }\n\n    if (fileType.includes(typeCriteria)) {\n      return true;\n    }\n  }\n\n  return false;\n};","map":{"version":3,"sources":["/Users/admin/Documents/newgsa/src/views/operadores/helpers/files.helper.js"],"names":["defaultPrecisionMap","bytes","KB","MB","GB","TB","PB","getFormattedSize","precision","units","Number","isNaN","parseFloat","String","isFinite","unitIndex","unit","toFixed","checkFileSize","maximumSize","currentSizeInMB","checkFileMIMEType","fileType","allowedMimeTypes","mimeTypes","split","mimeType","typeCriteria","includes","substring","indexOf"],"mappings":"AAAA;AACA,OAAO,MAAMA,mBAAmB,GAAG;AAClCC,EAAAA,KAAK,EAAE,CAD2B;AAElCC,EAAAA,EAAE,EAAE,CAF8B;AAGlCC,EAAAA,EAAE,EAAE,CAH8B;AAIlCC,EAAAA,EAAE,EAAE,CAJ8B;AAKlCC,EAAAA,EAAE,EAAE,CAL8B;AAMlCC,EAAAA,EAAE,EAAE;AAN8B,CAA5B;AASP,OAAO,MAAMC,gBAAgB,GAAG,CAACN,KAAK,GAAG,CAAT,EAAYO,SAAS,GAAGR,mBAAxB,KAAgD;AAC/E,QAAMS,KAAK,GAAG,CAAC,OAAD,EAAU,IAAV,EAAgB,IAAhB,EAAsB,IAAtB,EAA4B,IAA5B,EAAkC,IAAlC,CAAd;;AACA,MAAIC,MAAM,CAACC,KAAP,CAAaC,UAAU,CAACC,MAAM,CAACZ,KAAD,CAAP,CAAvB,KAA2C,CAACS,MAAM,CAACI,QAAP,CAAgBb,KAAhB,CAAhD,EAAwE;AACvE,WAAO,GAAP;AACA;;AACD,MAAIc,SAAS,GAAG,CAAhB;;AACA,SAAOd,KAAK,IAAI,IAAhB,EAAsB;AACrBA,IAAAA,KAAK,IAAI,IAAT;AACAc,IAAAA,SAAS,IAAI,CAAb;AACA;;AACD,QAAMC,IAAI,GAAGP,KAAK,CAACM,SAAD,CAAlB;;AACA,MAAI,OAAOP,SAAP,KAAqB,QAAzB,EAAmC;AAClC,WAAQ,GAAEP,KAAK,CAACgB,OAAN,CAAc,CAACT,SAAf,CAA0B,IAAGQ,IAAK,EAA5C;AACA;;AACD,SAAQ,GAAEf,KAAK,CAACgB,OAAN,CAAcT,SAAS,CAACQ,IAAD,CAAvB,CAA+B,IAAGA,IAAK,EAAjD;AACA,CAfM;AAiBP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAME,aAAa,GAAG,CAACjB,KAAD,EAAQkB,WAAR,KAAwB;AACpD,QAAMC,eAAe,GAAGnB,KAAK,GAAG,IAAR,GAAe,IAAvC;;AACA,MAAImB,eAAe,IAAID,WAAvB,EAAoC;AACnC,WAAO,KAAP;AACA;;AACD,SAAO,IAAP;AACA,CANM;AAQP,OAAO,MAAME,iBAAiB,GAAG,CAACC,QAAD,EAAWC,gBAAX,KAAgC;AAChE,QAAMC,SAAS,GAAGD,gBAAgB,CAACE,KAAjB,CAAuB,IAAvB,CAAlB;;AACA,OAAK,MAAMC,QAAX,IAAuBF,SAAvB,EAAkC;AACjC,QAAIG,YAAY,GAAG,EAAnB;;AACA,QAAID,QAAQ,CAACE,QAAT,CAAkB,GAAlB,CAAJ,EAA4B;AAC3BD,MAAAA,YAAY,GAAGD,QAAQ,CAACG,SAAT,CAAmB,CAAnB,EAAsBH,QAAQ,CAACI,OAAT,CAAiB,GAAjB,CAAtB,CAAf;AACA,KAFD,MAEO,IAAIJ,QAAQ,CAACE,QAAT,CAAkB,GAAlB,KAA0B,CAACJ,SAAS,CAACI,QAAV,CAAmB,GAAnB,CAA/B,EAAwD;AAC9DD,MAAAA,YAAY,GAAGD,QAAQ,CAACG,SAAT,CAAmBH,QAAQ,CAACI,OAAT,CAAiB,GAAjB,IAAwB,CAA3C,CAAf;AACA,KAFM,MAEA;AACNH,MAAAA,YAAY,GAAGD,QAAf;AACA;;AACD,QAAIJ,QAAQ,CAACM,QAAT,CAAkBD,YAAlB,CAAJ,EAAqC;AACpC,aAAO,IAAP;AACA;AACD;;AACD,SAAO,KAAP;AACA,CAhBM","sourcesContent":["/* eslint-disable no-restricted-syntax */\nexport const defaultPrecisionMap = {\n\tbytes: 0,\n\tKB: 0,\n\tMB: 1,\n\tGB: 1,\n\tTB: 2,\n\tPB: 2\n};\n\nexport const getFormattedSize = (bytes = 0, precision = defaultPrecisionMap) => {\n\tconst units = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n\tif (Number.isNaN(parseFloat(String(bytes))) || !Number.isFinite(bytes)) {\n\t\treturn '?';\n\t}\n\tlet unitIndex = 0;\n\twhile (bytes >= 1024) {\n\t\tbytes /= 1024;\n\t\tunitIndex += 1;\n\t}\n\tconst unit = units[unitIndex];\n\tif (typeof precision === 'number') {\n\t\treturn `${bytes.toFixed(+precision)} ${unit}`;\n\t}\n\treturn `${bytes.toFixed(precision[unit])} ${unit}`;\n};\n\n/**\n * Validate if the size of a file is bigger than the expected size\n *\n * @param bytes Size in bytes\n * @param maximumSize Maximum size in MB\n * @returns `true` is the file size is under or equals to the expected size. IF not, returns `false`\n */\nexport const checkFileSize = (bytes, maximumSize) => {\n\tconst currentSizeInMB = bytes / 1024 / 1024;\n\tif (currentSizeInMB >= maximumSize) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\nexport const checkFileMIMEType = (fileType, allowedMimeTypes) => {\n\tconst mimeTypes = allowedMimeTypes.split(', ');\n\tfor (const mimeType of mimeTypes) {\n\t\tlet typeCriteria = '';\n\t\tif (mimeType.includes('*')) {\n\t\t\ttypeCriteria = mimeType.substring(0, mimeType.indexOf('/'));\n\t\t} else if (mimeType.includes('.') && !mimeTypes.includes('/')) {\n\t\t\ttypeCriteria = mimeType.substring(mimeType.indexOf('.') + 1);\n\t\t} else {\n\t\t\ttypeCriteria = mimeType;\n\t\t}\n\t\tif (fileType.includes(typeCriteria)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\n"]},"metadata":{},"sourceType":"module"}